ARM GAS  /tmp/cchhzdJK.s 			page 1


   1              		.cpu cortex-m0
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"handyarm.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "../handyarm.c"
  18              		.section	.text._read,"ax",%progbits
  19              		.align	1
  20              		.global	_read
  21              		.syntax unified
  22              		.code	16
  23              		.thumb_func
  25              	_read:
  26              	.LVL0:
  27              	.LFB3:
   1:../handyarm.c **** #include <stdlib.h>
   2:../handyarm.c **** #include <stdio.h>
   3:../handyarm.c **** #include <stdint.h>
   4:../handyarm.c **** #include "handyarm.h"
   5:../handyarm.c **** 
   6:../handyarm.c **** //Set the address(s) used for the data channels (Can be multiple, if the host mapped multiple)
   7:../handyarm.c **** #define CONSOLE_DT ((0xE0000000))  //Transmit Channel (Sending data from us to the host)
   8:../handyarm.c **** #define CONSOLE_DR ((0xE0001000))  //Receive Channel  (Sending data from host to us)
   9:../handyarm.c **** 
  10:../handyarm.c **** int _read(int file, char *ptr, int len){
  28              		.loc 1 10 40 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		.loc 1 10 40 is_stmt 0 view .LVU1
  33 0000 30B5     		push	{r4, r5, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 12
  36              		.cfi_offset 4, -12
  37              		.cfi_offset 5, -8
  38              		.cfi_offset 14, -4
  11:../handyarm.c **** //  (void)file;
  12:../handyarm.c ****   uint32_t DataIdx = 0;
  39              		.loc 1 12 3 is_stmt 1 view .LVU2
  40              	.LVL1:
  13:../handyarm.c **** 
  14:../handyarm.c ****   volatile uint8_t *readbuffer = HandyARM_R(CONSOLE_DR)->buffer;
  41              		.loc 1 14 3 view .LVU3
  15:../handyarm.c ****   while(HandyARM_R(CONSOLE_DR)->start_offset != HandyARM_R(CONSOLE_DR)->end_offset){
  42              		.loc 1 15 3 view .LVU4
  12:../handyarm.c **** 
ARM GAS  /tmp/cchhzdJK.s 			page 2


  43              		.loc 1 12 12 is_stmt 0 view .LVU5
  44 0002 0020     		movs	r0, #0
  45              	.LVL2:
  46              	.L2:
  47              		.loc 1 15 46 is_stmt 1 view .LVU6
  48              		.loc 1 15 31 is_stmt 0 view .LVU7
  49 0004 084B     		ldr	r3, .L5
  50 0006 1C68     		ldr	r4, [r3]
  51              		.loc 1 15 71 view .LVU8
  52 0008 5B68     		ldr	r3, [r3, #4]
  53              		.loc 1 15 46 view .LVU9
  54 000a 9C42     		cmp	r4, r3
  55 000c 0BD0     		beq	.L3
  16:../handyarm.c ****     ptr[DataIdx] = readbuffer[HandyARM_R(CONSOLE_DR)->start_offset];
  56              		.loc 1 16 5 is_stmt 1 view .LVU10
  57              		.loc 1 16 53 is_stmt 0 view .LVU11
  58 000e 064C     		ldr	r4, .L5
  59 0010 2368     		ldr	r3, [r4]
  60              		.loc 1 16 30 view .LVU12
  61 0012 064D     		ldr	r5, .L5+4
  62 0014 AC46     		mov	ip, r5
  63 0016 6344     		add	r3, r3, ip
  64 0018 1B78     		ldrb	r3, [r3]
  65              		.loc 1 16 18 view .LVU13
  66 001a 0B54     		strb	r3, [r1, r0]
  17:../handyarm.c ****     (HandyARM_R(CONSOLE_DR))->start_offset=1; //increment the start position, now that we consumed 
  67              		.loc 1 17 5 is_stmt 1 view .LVU14
  68              		.loc 1 17 43 is_stmt 0 view .LVU15
  69 001c 0123     		movs	r3, #1
  70 001e 2360     		str	r3, [r4]
  18:../handyarm.c **** 
  19:../handyarm.c ****     DataIdx++;
  71              		.loc 1 19 5 is_stmt 1 view .LVU16
  72              		.loc 1 19 12 is_stmt 0 view .LVU17
  73 0020 0130     		adds	r0, r0, #1
  74              	.LVL3:
  20:../handyarm.c ****     if(DataIdx == len){
  75              		.loc 1 20 5 is_stmt 1 view .LVU18
  76              		.loc 1 20 7 is_stmt 0 view .LVU19
  77 0022 8242     		cmp	r2, r0
  78 0024 EED1     		bne	.L2
  79              	.L3:
  21:../handyarm.c ****        break;
  22:../handyarm.c ****     }
  23:../handyarm.c ****   }
  24:../handyarm.c ****   
  25:../handyarm.c ****   return DataIdx;
  80              		.loc 1 25 3 is_stmt 1 view .LVU20
  26:../handyarm.c **** }
  81              		.loc 1 26 1 is_stmt 0 view .LVU21
  82              		@ sp needed
  83 0026 30BD     		pop	{r4, r5, pc}
  84              	.L6:
  85              		.align	2
  86              	.L5:
  87 0028 001000E0 		.word	-536866816
  88 002c 001100E0 		.word	-536866560
ARM GAS  /tmp/cchhzdJK.s 			page 3


  89              		.cfi_endproc
  90              	.LFE3:
  92              		.section	.text._write,"ax",%progbits
  93              		.align	1
  94              		.global	_write
  95              		.syntax unified
  96              		.code	16
  97              		.thumb_func
  99              	_write:
 100              	.LVL4:
 101              	.LFB4:
  27:../handyarm.c **** 
  28:../handyarm.c **** int _write(int file, char *ptr, int len){
 102              		.loc 1 28 41 is_stmt 1 view -0
 103              		.cfi_startproc
 104              		@ args = 0, pretend = 0, frame = 0
 105              		@ frame_needed = 0, uses_anonymous_args = 0
 106              		@ link register save eliminated.
 107              		.loc 1 28 41 is_stmt 0 view .LVU23
 108 0000 1000     		movs	r0, r2
 109              	.LVL5:
  29:../handyarm.c **** //  (void)file;
  30:../handyarm.c **** 
  31:../handyarm.c ****   HandyARM_T(CONSOLE_DT)->start_addr = ptr;
 110              		.loc 1 31 3 is_stmt 1 view .LVU24
 111              		.loc 1 31 38 is_stmt 0 view .LVU25
 112 0002 E023     		movs	r3, #224
 113 0004 1B06     		lsls	r3, r3, #24
 114 0006 1960     		str	r1, [r3]
  32:../handyarm.c ****   HandyARM_T(CONSOLE_DT)->length = len; //The transfer is automatically performed by the host when 
 115              		.loc 1 32 3 is_stmt 1 view .LVU26
 116              		.loc 1 32 34 is_stmt 0 view .LVU27
 117 0008 5A60     		str	r2, [r3, #4]
  33:../handyarm.c ****                             //This allows for us to keep the "start" the same if we wanted to.
  34:../handyarm.c ****                             //but for this system call, we'll just do it via a "zero copy" method, 
  35:../handyarm.c ****                             //and let the host handle reading it from the bus as necessary
  36:../handyarm.c **** 
  37:../handyarm.c ****   return len;
 118              		.loc 1 37 3 is_stmt 1 view .LVU28
  38:../handyarm.c **** }
 119              		.loc 1 38 1 is_stmt 0 view .LVU29
 120              		@ sp needed
 121 000a 7047     		bx	lr
 122              		.cfi_endproc
 123              	.LFE4:
 125              		.text
 126              	.Letext0:
 127              		.file 2 "/home/kaylee/.arduino15/packages/STMicroelectronics/tools/xpack-arm-none-eabi-gcc/13.2.1-
 128              		.file 3 "/home/kaylee/.arduino15/packages/STMicroelectronics/tools/xpack-arm-none-eabi-gcc/13.2.1-
 129              		.file 4 "../handyarm.h"
ARM GAS  /tmp/cchhzdJK.s 			page 4


DEFINED SYMBOLS
                            *ABS*:00000000 handyarm.c
     /tmp/cchhzdJK.s:19     .text._read:00000000 $t
     /tmp/cchhzdJK.s:25     .text._read:00000000 _read
     /tmp/cchhzdJK.s:87     .text._read:00000028 $d
     /tmp/cchhzdJK.s:93     .text._write:00000000 $t
     /tmp/cchhzdJK.s:99     .text._write:00000000 _write

NO UNDEFINED SYMBOLS
